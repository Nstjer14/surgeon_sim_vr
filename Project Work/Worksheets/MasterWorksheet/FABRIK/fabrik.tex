\chapter{FABRIK}
Forwards and Backwards Reaching Inverse Kinematics (FABRIK) is an algorithm that efficiently solves inverse kinematics (IK) for a number of joints in a system. Being a heuristic model, FABRIK avoids solving rotational matrices as conventional IK solvers, and instead translates the joints to a point on a line. This results in low computational requirements. A table comparing FABRIK to other IK solvers is shown in \autoref{tab:IKS}. 

\begin{table}[H]
	\centering
	
	\resizebox{\textwidth}{!}{
	\begin{tabular}{l|llll}
		\rowcolor[HTML]{BBDAFF}
	       & \textbf{Number of iterations} & \textbf{Matlab exe. time (sec)} & \textbf{Time per iteration (msec)} & \textbf{Iteration per second} \\
	FABRIK & 15.461                        & 0.01328                         & 0.86                               & 1164                          \\ \rowcolor{lightGrey}
	CCD    & 26.308                        & 0.12356                         & 4.69                               & 213                           \\
	FTL    & 21.125                        & 0.02045                        & 0.97                               & 1033                          \\ 
	\end{tabular}
	}
	\caption{Average results from different IK methods for a system with 10 joints \citep{aristidou_fabrik:_2011}}
	\label{tab:IKS}
\end{table}


The following section describes how FABRIK have been implemented and applied to the virtual da Vinci robot. It also describes the current problems with the algorithm and its implementation in Unreal Engine. 
The algorithm have been implemented according to Andreas Aristidou and Joan Lasenby \citep{aristidou_fabrik:_2011}.  %Its in zotero. 

FABRIK is implemented in Unreal Engine's Animation Blueprint, but as this only allows to define preset animation sequences, it cannot be used to interact with in real-time. Standard Blueprints does not allow for bone or joint transformations and therefore a Poseable Mesh has to be created from the Skeletal Mesh of the robot in order to program bone behaviour. 

\section{FABRIK Algorithm Example}
\autoref{fig:ab} shows an example of a system consisting of four bones and an end-effector. The goal of the algorithm is to get the outermost bone $ (P4) $ as close to the end effector $ (t) $ as possible and maintaining the original distance between each bone. 
The FABRIK algorithm starts by adding all bone lengths together to determine if the target is reachable or not. 
As FABRIK is a heuristic bone translation algorithm it starts at the end effector $ P4 $ and sets its position to the target's position as seen in \autoref{fig:ab}. The new heuristic joint is called $ P'4 $ 

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{FABRIK/ab}
	\caption{First two stages in FABRIK; calculating positions based on end-effector position and bone lengths}
	\label{fig:ab}
\end{figure}

A line is then drawn from $ P'4 $ to $ P3 $, and since the original distance have to be maintained, $ P'3 $ is translated to somewhere on that line as seen in Figure \ref{fig:cd}. The position on the line is calculated using \autoref{eq:line_pos}

\begin{equation}\label{eq:line_pos}
	P'3 = (\hat{P3 - P'4}) \cdot d_{3}
\end{equation}


This procedure is then repeated for each bone in the system, creating a heuristic position for all joints, as seen in \autoref{fig:cd}. This results in the root bone $ (P1) $ being translated as well. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{FABRIK/cd}
	\caption{Position of all joints are being recalculated, resulting in a slight offset from the root bone's original position}
	\label{fig:cd}
\end{figure}

The root joint is then moved back to its initial position and the same process now repeats in the other direction (root to outer joint) as seen in \autoref{fig:ef}.

\begin{figure}[H]
	 \centering
	 \includegraphics[width=\textwidth]{FABRIK/ef}
	 \caption{The same process now repeats, now where the root bone is moved back to its original position. These processes repeat until the end effector is within a predefined distance to the target}
	 \label{fig:ef}
 \end{figure} 

\section{Implementation in Unreal Engine}

For implementation purposes, Unreal Engine's Poseable Mesh Blueprint was used to translate the bones toward the target. \autoref{tab:blueprint} shows the variables used by the Blueprint with a description of its use. 

% Please add the following required packages to your document preamble:
% \usepackage[table,xcdraw]{xcolor}
% If you use beamer only pass "xcolor=table" option, i.e. \documentclass[xcolor=table]{beamer}
\begin{table}[]
\centering

\resizebox{\textwidth}{!}{
\begin{tabular}{l|lll}
\rowcolor[HTML]{BBDAFF} 
\textbf{Variable Name} & \textbf{Type} & \textbf{Use} & \textbf{Static} \\

\textbf{Arm1}  & Array of Bones  & Contains all the bones of the robot arm. Used to reference.  & Yes  \\ 

\rowcolor{lightGrey}
\textbf{BoneLocations}   & Array of Positions  & \begin{tabular}[c]{@{}l@{}}Contains all the bones' positions in world space. \\ Used in the start to calculate the original distances \\ between joints and updated later when new positions \\ are calculated.\end{tabular}    & No  \\ 

\textbf{Lengths} & Array of Bone Lengths & \begin{tabular}[c]{@{}l@{}}The array of bone lengths is constant and is needed to \\ calculate positions.\end{tabular}   & Yes    \\ 

\rowcolor{lightGrey}
\textbf{Target}    & Object   & \begin{tabular}[c]{@{}l@{}}The actual object that the end effector will try to reach. \\ This is a red semi transparent cube used to set the end\\ -effector's position to the target and to calculate proximity.\end{tabular} & Yes  \\


\textbf{Origin1} & Position & \begin{tabular}[c]{@{}l@{}}The root's original position. Used in the start of the "Forwards"\\ part where the root's position is set to its original position.\end{tabular}  & Yes  \\                                       
\end{tabular}
}
\caption{Table of the important variables of FABRIK}
\label{tab:blueprint}
\end{table}

The code is split up in four main parts:

\begin{itemize}
\item BeginPlay
\item OutOfReach
\item Backwards (Heuristics)
\item Forwards (Positioning joints)
\end{itemize}

BeginPlay initializes and calculates all of the variables in \autoref{tab:table}. OutOfReach determines if the target is out of reach and, if so, stretches all bones in the target's direction. 
Backwards handles the heuristics of the algorithm and the flow of this program can be seen in Figure \ref{fig:flow}. Forwards then calculates the real position of the joint and sets the position of the joints in world space. Forwards look like the flow in Figure \ref{fig:flow} the only difference being a positive for loop and the order in the "pos" calculation.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{FABRIK/Flowchart.png}
	\caption{Flowchart showing the Backwards part of the FABRIK algorithm}
	\label{fig:flow}
\end{figure}

\section{Results}
The results of this implementation is shown in \autoref{fig:results}. It is clear that the implementation did not work as intended, as a small movement of the target transforms the bones with this magnitude. This is the case no matter what direction the target is moved. 


\begin{figure}[H]
	\begin{subfigure}[b]{0.48\textwidth}
	\includegraphics[width=\textwidth]{FABRIK/Robot_state1.PNG}
	\caption{The robot and its bones in one state with the target visible}
	\end{subfigure} 
	\begin{subfigure}[b]{0.48\textwidth}
	\includegraphics[width=\textwidth]{FABRIK/Robot_state2.PNG}
	\caption{The robot in another state where the target has moved slightly}
	\end{subfigure}
	\label{fig:results}
\end{figure}


Looking at the target out of reach as seen in \autoref{fig:outofreach}, the IK acts as expected and only points towards the target without any radical movements. 

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{FABRIK/Robot_OutOfReach.PNG}
	\caption{The arms when the target is out of reach}
	\label{fig:outofreach}
\end{figure}

One of the reasons the FABRIK acts radically when the target is in reach might be because of the Blueprint implementation. Blueprints lack several basic features such as reverse for-loops. This leads to more complexity of the code, since these have to be programmed in Blueprints. As complexity increases debugging also gets more difficult. 
Due to time constraints the Cyclic Coordinate Descent algorithm was implemented instead. 